# 常见算法总结
## 递归和动态规划
动态规划问题的一般形式就是**求最值**，比如**最长**递增子序列，**最小**编辑距离等。


动态规划的核心思想是**穷举求最值**，因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。


但是不是暴力穷举，因为动态规划问题的一个特点是存在**重叠子问题**，所以需要**备忘录**或者**DP Table**来优化穷举过程，避免不必要的计算。


动态规划问题的第二个特点是具备**最优子结构**，才能通过子问题的最值得到原问题的最值。


如何理解最优子结构，比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。


但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。


动态规划的三要素是重叠子问题，最优子结构和状态转移方程。


如何思考状态转移方程？</br>
明确base case -> 明确状态 -> 明确选择 -> 定义dp数组的含义</br>


以凑零钱的问题为例，给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。

1. **确定base case**，目标金额amount为0时算法返回0，因为不需要任何硬币就已经凑出目标金额。


2. **确定状态（原问题和子问题中会变化的量）**，由于硬币的数量无限，硬币的面额也是给定的，只有目标金额会不断的向base case靠近，所以唯一的状态就是目标金额amount。

3. **确定选择（导致状态产生变化的行为）**，目标金额为什么变化呢，因为在选择硬币的时候，每次选择一枚硬币，就会减少目标金额。所以所有硬币的面值就是选择。

4. **确定dp数组的定义**， 这里采用自顶向下的解法，所以会有一个递归的dp函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的状态；函数的返回值是题目要求我们计算的量。就本题来说，状态只有一个即目标金额，题目要求我们计算凑出目标金额所需的最少硬币数量。

所以dp(n)的定义：输入一个目标金额n，返回凑出目标金额n的最少硬币数量。

```python
# 伪代码
def coinChange(coins: List[int], amount: int):
  # dp函数（递归函数）
  def dp(n):
    # 做选择，选择需要硬币最少的那个结果
    for coin in coins:
      res = main(res, dp(n - coin) + 1)
     return res
  # 最终结果
  return dp(amount)
```
这类问题通常有两种思路且这两种思路通常时间复杂度相同。
### 自顶向下：带备忘录的递归
需要构造dp函数
```python
def coinChange(coins, amount):
  # 备忘录
  memo = dict()
  def dp(n):
      # 查看备忘录，避免重复计算
      if n in memo: return memo[n]
      # base case
      if n == 0: return 0
      if n < 0: return -1
      res = float('INF)
      for coin in coins:
          subproblem = dp(n - coin)
          # 子问题无解，跳过
          if subproblem == -1: continue
          res = min(res, 1 + subproblem)
      # 计入备忘录
      memo[n] = res if res != float('INF') else -1
      return res if res != float('INF') else -1
   
   return dp(amount)
```

### 自底向上：dp数组的迭代
需要构造dp数组，与dp函数类似，也是把状态作为变量，不过dp函数体现在函数参数上，而dp数组体现在数组索引上。</br>
dp数组定义：当目标金额为i时，至少需要dp[i]美硬币凑出。
```python
def coinChange(coins, amount):
    dp = [amount + 1] * n for n in range(amount + 1)
    # 外层for循环遍历所有状态的所有取值
    for i in range(amount + 1):
        # 内层for循环求所有选择的最小值
        for coin in coins:
            # 子问题无解，跳过
            if i - coin < 0: continue
            dp[i] = min(dp[i], 1 + dp[i - coin])
    return dp[amount] if dp[amount + 1] != amount + 1 else -1
```
PS：为啥 dp 数组初始化为 amount + 1 呢?因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币），所以初始化为 amount + 1 就相当于初始化为正无穷，便于后续取最小值。

## 回溯法Backtracing
## 广度优先搜素BFS
